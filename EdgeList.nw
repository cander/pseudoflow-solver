\subsection{Lists of Nodes}
To represent the original graph, we need a list of the neighbors
of a node.  To represent a tree, we need a list of the children
Nodes.  In both cases, the number of nodes in the list is
bounded by the degree of the node.  
{\em However, for a child list, during rehang operations we 
will be removing nodes and adding them.  Because we want to
avoid compacting the list (slow), we should allow the list
to be dynamic.  For the moment, we will ignore this and will
revisit it later.}

A list is simply an array of node pointers, a capacity, and a current
size.
<<NodeList data>>=
    NodePtr*	array;
    int		capacity;
    int		size;
@ Here are constructors and an initialization method for use after a
constructor has already been called (e.g. after allocating an array
of NodeLists).
<<NodeList methods>>=
public:
    NodeList();
    NodeList(int cap);
    void init(int cap);
<<NodeList inline implementations>>=
INLINE NodeList::NodeList()
{ array = nil; capacity = size = 0; }
INLINE NodeList::NodeList(int cap) : array(nil)
{ init(cap); }
<<NodeList method implementations>>=
void NodeList::init(int cap)
{ 
    delete array; 
    array = new NodePtr[cap]; 
    capacity = cap; size = 0;
    for (int i = 0; i < cap; i++) {
	array[i] = nil;
    }
}
@
The point of the list is to store items, so we need a way to add elements
to the list.  The simplist is to add an element to the end of the list.
<<NodeList methods>>=
    void appendNode(NodePtr nodep);
<<NodeList method implementations>>=
void NodeList::appendNode(NodePtr nodep)
{
    assert((array != nil) && (size < capacity));
    array[size] = nodep;
    size++;
}
@ %def appendNode
We need methods to iterate over these lists of nodes.  We have no
requirement to support multiple simultaneous iterations, so we can
implement the functions and the iteration state directly on the
node list class (\{em someday using STL would make sense).
The methods are pretty straightforward.
<<NodeList methods>>=
    void beginIteration();
    Boolean hasMoreElements();
    NodePtr getCurrentElement();
    void advanceToNextElement();
@ 
With this simple interface, we only need to keep track of
the current index into the array to implement a cursor, 
and begining the iteration is trivial.
<<NodeList data>>=
    int currentIndex;
<<NodeList inline implementations>>=
INLINE void NodeList::beginIteration()
{ currentIndex = 0; }
@ %def currentIndex beginIteration
Because we allow `holes' to exist within a childlist, the code
for the other methods needs to be prepared to skip over
holes.  So, we add a method to skip over any holes begining
at the current position.
It will either leave the cursor pointing to
the first non-hole or the end of the array.
<<NodeList internal methods>>=
    void skipHoles();
<<NodeList inline implementations>>=
void NodeList::skipHoles()
{
    while ((array[currentIndex] == nil) && (currentIndex <= size)) {
	currentIndex++;
    }
}
@ %def skipHoles
With [[skipHoles]] in place, the other methods are pretty simple
to implement.  Basically, they use [[skipHoles]] to update the
cursor, and perform their real work.  [[hasMoreElements]] just
tells us if there are any more non-hole elements in the list.
<<NodeList inline implementations>>=
INLINE Boolean NodeList::hasMoreElements()
{
    skipHoles();
    return (currentIndex == size) ? TRUE : FALSE;
}
@ %def hasMoreElements
[[getCurrentElement]] returns the element at the current position.
This should almost never be a whole because callers should
call [[hasMoreElements]] first.  Currently, we raise an assertion
if this happens.  We can fix it later if need be.
<<NodeList inline implementations>>=
INLINE NodePtr NodeList::getCurrentElement()
{
    assert((currentIndex < size) && (array[currentIndex] != nil));
    return array[currentIndex];
}
@ %def getCurrentElement
The [[advanceToNextElement]] moves us to the next non-hole
element unless we're at the end of the array already, in
which case it is a no-op.
<<NodeList inline implementations>>=
INLINE void NodeList::advanceToNextElement()
{
    if (currentIndex < size) {
	currentIndex++;
	skipHoles();
    }
}
@ %def advanceToNextElement
While performing rehang operations, a Node needs to remove
the child pointed to by the current cursor.  This is
the cause of holes in the list.  We pass in the value
that we expect to be at the cursor, mostly out of
paranoia.
<<NodeList methods>>=
    void removeCurrentElement(NodePtr nodep);
<<NodeList inline implementations>>=
INLINE void NodeList::removeCurrentElement(NodePtr nodep)
{
    assert((currentIndex < size) && (array[currentIndex] == nodep));
    array[currentIndex] = nil;
}
@ %def removeCurrentElement
\subsubsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "NodeList.h"
#include "debug.h"
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>

<<NodeList method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_NODELIST
#define INLINE /*inline*/
<<NodeList inline implementations>>
#undef INLINE 
#endif /*INLINE_NODELIST*/
@
The header defines the [[NodeList]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef NODELIST_H
#define NODELIST_H
#include "types.h"

class NodeList 
{
    <<NodeList methods>>
protected:
    <<NodeList internal methods>>
private:
    <<NodeList data>>
};
@ %def NodeList
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_NODELIST
#define INLINE inline
<<NodeList inline implementations>>
#undef INLINE 
#endif /*INLINE_NODELIST*/

#endif /*NODELIST_H*/
