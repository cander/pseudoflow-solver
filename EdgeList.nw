\subsection{Lists of Edges}
To represent the original graph, we need a list of the neighbors
of a node.  To represent a tree, we need a list of the children
Nodes.  However, as we scan for merger arcs or rehang the tree,
we need more than just a pointer to a Node, we also need the
edge that defines the relationship between the two nodes.  Therefore,
we need a list of Edges rather than a list of Nodes.

In principal, the number of edges in the list is
bounded by the degree of the node.  
{\em However, for a child list, during rehang operations we 
will be removing nodes and adding them.  Because we want to
avoid compacting the list (slow) after deleting a node, we 
should allow the list
to be dynamic.  For the moment, we will ignore this and will
revisit it later.}

A list is simply an array of Edge pointers, a capacity, and a current
size.
<<EdgeList data>>=
    EdgePtr*	array;
    int		capacity;
    int		size;
@ Here are constructors and an initialization method for use after a
constructor has already been called (e.g. after allocating an array
of NodeLists).
<<EdgeList methods>>=
public:
    EdgeList();
    EdgeList(int cap);
    void init(int cap);
<<EdgeList inline implementations>>=
INLINE EdgeList::EdgeList()
{ array = nil; capacity = size = 0; }
INLINE EdgeList::EdgeList(int cap) : array(nil)
{ init(cap); }
<<EdgeList method implementations>>=
void EdgeList::init(int cap)
{ 
    delete array; 
    array = new EdgePtr[cap]; 
    capacity = cap; size = 0;
    for (int i = 0; i < cap; i++) {
	array[i] = nil;
    }
    beginIteration();
}
@
The point of the list is to store items, so we need a way to add elements
to the list.  The simplist is to add an element to the end of the list.
<<EdgeList methods>>=
    void appendEdge(EdgePtr edgep);
<<EdgeList method implementations>>=
void EdgeList::appendEdge(EdgePtr edgep)
{
    assert((array != nil) && (size < capacity));
    array[size] = edgep;
    size++;
}
@ %def appendEdge
We need methods to iterate over these lists of edges.  We have no
requirement to support multiple simultaneous iterations, so we can
implement the functions and the iteration state directly on the
edge list class (\{em someday using STL would make sense).
The methods are pretty straightforward.
<<EdgeList methods>>=
    void beginIteration();
    Boolean hasMoreElements();
    EdgePtr getCurrentElement();
    void advanceToNextElement();
@ 
With this simple interface, we only need to keep track of
the current index into the array to implement a cursor, 
and begining the iteration is trivial.
<<EdgeList data>>=
    int currentIndex;
<<EdgeList inline implementations>>=
INLINE void EdgeList::beginIteration()
{ currentIndex = 0; }
@ %def currentIndex beginIteration
Because we allow `holes' to exist within a childlist, the code
for the other methods needs to be prepared to skip over
holes.  So, we add a method to skip over any holes begining
at the current position.
It will either leave the cursor pointing to
the first non-hole or the end of the array.
<<EdgeList internal methods>>=
    void skipHoles();
<<EdgeList inline implementations>>=
void EdgeList::skipHoles()
{
    while ((array[currentIndex] == nil) && (currentIndex < size)) {
	currentIndex++;
    }
}
@ %def skipHoles
With [[skipHoles]] in place, the other methods are pretty simple
to implement.  Basically, they use [[skipHoles]] to update the
cursor, and perform their real work.  [[hasMoreElements]] just
tells us if there are any more non-hole elements in the list.
<<EdgeList inline implementations>>=
INLINE Boolean EdgeList::hasMoreElements()
{
    skipHoles();
    return (currentIndex < size) ? TRUE : FALSE;
}
@ %def hasMoreElements
[[getCurrentElement]] returns the element at the current position.
This should almost never be a hole because callers should
call [[hasMoreElements]] first.  Currently, we raise an assertion
if this happens.  We can fix it later if need be.
<<EdgeList inline implementations>>=
INLINE EdgePtr EdgeList::getCurrentElement()
{
    assert((currentIndex < size) && (array[currentIndex] != nil));
    return array[currentIndex];
}
@ %def getCurrentElement
The [[advanceToNextElement]] moves us to the next non-hole
element unless we're at the end of the array already, in
which case it is a no-op.
<<EdgeList inline implementations>>=
INLINE void EdgeList::advanceToNextElement()
{
    if (currentIndex < size) {
	currentIndex++;
	skipHoles();
    }
}
@ %def advanceToNextElement
While performing rehang operations, a Node needs to remove
the child pointed to by the current cursor.  This is
the cause of holes in the list.  We pass in the value
that we expect to be at the cursor, mostly out of
paranoia.
<<EdgeList methods>>=
    void removeCurrentElement(EdgePtr edgep);
<<EdgeList inline implementations>>=
INLINE void EdgeList::removeCurrentElement(EdgePtr edgep)
{
    assert((currentIndex < size) && (array[currentIndex] == edgep));
    array[currentIndex] = nil;
}
@ %def removeCurrentElement
Similarly, during rehang operations we need to put a Edge into
the list at the current cursor location, which should be a hole.
An exception is if the list is empty, in which case we aren't 
replacing the current cursor location but rather appending to
the list.
<<EdgeList methods>>=
    void addCurrentElement(EdgePtr edgep);
<<EdgeList inline implementations>>=
INLINE void EdgeList::addCurrentElement(EdgePtr edgep)
{
    if (size > 0) {
	assert((currentIndex < size) && (array[currentIndex] == nil));
	array[currentIndex] = edgep;
    } else {
	appendEdge(edgep);
    }
}
@ %def addCurrentElement
When a node is begin split from its parent, we need to remove a child
edge which is probably not the current edge.  At the moment, we implement
this via a linear search.  In the future, perhaps we could use a 
hashtable, but it might be difficult to iterate over that given that
a phase can be started and stopped multiple times.
<<EdgeList methods>>=
    void removeElement(EdgePtr edgep);
<<EdgeList method implementations>>=
void EdgeList::removeElement(EdgePtr edgep)
{
    for (int i = 0; i < size; i++) {
	if (array[i] == edgep) {
	    array[i] = nil;
	    return;
	}
    }
    assert("failed to find edge");	// force assertion failure
}
@ %def removeElement
Here are some direct accessor methods for use during debugging.
These really should be 'hidden' and shared only to [[friends]].
<<EdgeList debug methods>>=
    int getSize() const;
    EdgePtr getElement(int i) const;
<<EdgeList method implementations>>=
int EdgeList::getSize() const
{ return size; }
EdgePtr EdgeList::getElement(int i) const
{
    assert(i < size);
    return array[i];
}
@
\subsubsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "EdgeList.h"
#include "debug.h"
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>

<<EdgeList method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_NODELIST
#define INLINE /*inline*/
<<EdgeList inline implementations>>
#undef INLINE 
#endif /*INLINE_NODELIST*/
@
The header defines the [[EdgeList]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef NODELIST_H
#define NODELIST_H
#include "types.h"

class EdgeList 
{
    <<EdgeList methods>>
    <<EdgeList debug methods>>
protected:
    <<EdgeList internal methods>>
private:
    <<EdgeList data>>
};
@ %def EdgeList
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_NODELIST
#define INLINE inline
<<EdgeList inline implementations>>
#undef INLINE 
#endif /*INLINE_NODELIST*/

#endif /*NODELIST_H*/
