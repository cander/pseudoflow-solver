\subsection{Edges}
\subsubsection{Structural Data}
An edge represents a relationship between two nodes, the source and
the destination.
<<Edge data>>=
    Node*	source;
    Node*	dest;
<<default Edge constructor>>=
    source = dest = nil;
@ %def source dest
For the purposes of the algorithm, an edge has an orientation that
idicates which direction we are pushing additional flow - i.e.
from child towards parent.  
<<Edge data>>=
    Boolean	isForward;
<<default Edge constructor>>=
    isForward = TRUE;
@ %def isForward
We can set the orientation in two ways: we can toggle or reverse it,
or we can set the orientation such that the forward direction points
towards either of the endpoints.
<<Edge methods>>=
    void toggleOrientation();
    void setDirectionTo(NodePtr endpoint);
<<Edge inline implementations>>=
INLINE void Edge::toggleOrientation()
{ isForward = isForward ? FALSE : TRUE; }
INLINE void Edge::setDirectionTo(NodePtr endpoint)
{
    assert(endpoint == source || endpoint == dest);
    isForward = (endpoint == dest) ? TRUE : FALSE;
}
@ %toggleOrientation setDirection
Since the source and destination of the edge are fixed with regard to
the original, forward orientation, we also need a way to get the
current head and tail of the edge - i.e. with respect to the orientation,
the edge goes from the tail to the head.
<<Edge methods>>=
    NodePtr getTail() const;
    NodePtr getHead() const;
<<Edge inline implementations>>=
INLINE NodePtr Edge::getTail() const
{ return (isForward == TRUE) ? source : dest; }
INLINE NodePtr Edge::getHead() const
{ return (isForward == TRUE) ? dest : source; }
@ %def getTail getHead
Regardless of the orientation of the node, given one endpoint we
want to be able to get the other node.
<<Edge methods>>=
    NodePtr getOtherNode(const NodePtr node) const;
<<Edge inline implementations>>=
INLINE NodePtr Edge::getOtherNode(const NodePtr node) const
{ return (node == source) ? dest : source; }
@ %def getOtherNode
\subsubsection{Flow Data}
<<Edge data>>=
    FlowAmount	capacity;
    FlowAmount	flow;
<<default Edge constructor>>=
    capacity = flow = 0;
@ %def capacity flow
Although the capacity of an edge is fixed during the duration of
the algorithm, the flow varies.  We always speak of {\em increasing}
the flow, but this is done with respect to the current orientation
of the edge, so it may in fact be reducing the amount of flow if
the current orientation is backwards.
<<Edge methods>>=
public:
    void increaseFlow(FlowAmount amt);
<<Edge inline implementations>>=
INLINE void Edge::increaseFlow(FlowAmount amt)
{ 
    if (isForward) {
	assert ((capacity - flow) >= amt);
	flow += amt;
    } else {
	assert(flow >= amt);
	flow -= amt;
    }
}
@ %def increaseFlow
We need to to define the residual
capacity with respect to the current orientation and from one node
to the other.
<<Edge methods>>=
public:
    FlowAmount residCapacity() const;
    FlowAmount residCapacity(const Node& node) const;
<<Edge inline implementations>>=
INLINE FlowAmount Edge::residCapacity() const
{ 
    if (isForward) {
	return capacity - flow;
    } else {
	return flow;
    }
}
INLINE FlowAmount Edge::residCapacity(const Node& node) const
{ 
    if (&node == source) {
	return capacity - flow;
    } else {
	return flow;
    }
}
@ %def residCapacity
We need a default constructor because we will be creating an
array of edges in bulk when we know how many of them are
in the graph.
<<Edge methods>>=
    Edge();
<<Edge method implementations>>=
Edge::Edge()
{
    <<default Edge constructor>>
}
@
After constructing an edge, we will need to initialize it.  
The default orientation will be from the source to the destination.
<<Edge methods>>=
    void init(Node& src, Node& dst, FlowAmount cap);
<<Edge method implementations>>=
void Edge::init(Node& src, Node& dst, FlowAmount cap)
{
    source = &src;
    dest = &dst;
    flow = 0;
    capacity = cap;
    isForward = TRUE;
}
@ %def init
At the begining of the algorithm, we need to saturate the
source- and sink-adjacent edges.
<<Edge methods>>=
    FlowAmount saturate();
<<Edge method implementations>>=
FlowAmount Edge::saturate()
{ flow = capacity; return flow; }
@ %def saturate
We need a way to print the contents of an edge to an output stream,
mostly for debugging.
<<C++ overhead>>=
    friend ostream& operator<<(ostream& out, const Edge& edge);
<<Edge method implementations>>=
ostream& operator<<(ostream& out, const Edge& edge)
{
    out << "(" << &edge << "): ";
    if (edge.isForward == TRUE) {
	out << edge.source->getId() << "(src) --> " 
	    << edge.dest->getId() << "(dest)";
    } else {
	out << edge.dest->getId() << "(dest) --> "
	    << edge.source->getId() << "(src)";
    }
    return out << " [" << edge.flow << "," << edge.capacity << "]";
}
<<Edge header include files>>=
class ostream;
@
Here's another debugging function that just validates that a given
edge is in fact and edge between two specified nodes.  We don't care
which is the source or destination.  If the edge or nodes are not 
valid, we return false so that the caller can throw an assertion 
failure.
<<Edge methods>>=
    Boolean validateEdge(Node& node1, Node& node2);
<<Edge method implementations>>=
Boolean Edge::validateEdge(Node& node1, Node& node2)
{
    Boolean result = FALSE;
    if (source == &node1) {
	result = (dest == &node2) ? TRUE : FALSE;
    } else {
	result = (dest == &node1) ? TRUE : FALSE;
    }

    return result;
}
@ %def validateEdge
\subsubsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "Edge.h"
#include "Node.h"
#include "debug.h"
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>

<<Edge method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_EDGE
#define INLINE /*inline*/
<<Edge inline implementations>>
#undef INLINE 
#endif /*INLINE_EDGE*/
@
The header defines the [[Edge]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef EDGE_H
#define EDGE_H
#include "types.h"
<<Edge header include files>>

class Edge 
{
public:
    <<Edge methods>>
    <<C++ overhead>>
private:
    <<Edge data>>
};
@ %def Edge
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_EDGE
#define INLINE inline
<<Edge inline implementations>>
#undef INLINE 
#endif /*INLINE_EDGE*/

#endif /*EDGE_H*/
