\subsection{Edges}
We allocate an Edge object for each edge in the graph.  Edges store
the current flow and the maximum capacity between source and
destination Nodes.  
<<Edge data>>=
    FlowAmount	capacity;
    FlowAmount	flow;
    Node*	source;
    Node*	dest;
<<default Edge constructor>>=
    capacity = flow = 0;
    source = dest = nil;
@ %def capacity flow source dest
For the purposes of the algorithm, an edge has an orientation that
idicates which direction we are pushing additional flow - i.e.
from child towards parent.  This allows us to define the residual
capacity with respect to the current orientation.
<<Edge data>>=
    Boolean	isForward;
<<default Edge constructor>>=
    isForward = TRUE;
@ %def isForward
<<Edge methods>>=
public:
    FlowAmount residCapacity() const;
<<Edge inline implementations>>=
INLINE FlowAmount Edge::residCapacity() const
{ 
    if (isForward) {
	return capacity - flow;
    } else {
	return capacity;
    }
}
@ %def residCapacity
We can set the orientation in two ways: we can toggle or reverse it,
or we can set the orientation such that the forward direction points
towards either of the endpoints.
<<Edge methods>>=
    void toggleOrientation();
    void setDirectionTo(NodePtr endpoint);
<<Edge inline implementations>>=
INLINE void Edge::toggleOrientation()
{ isForward = isForward ? FALSE : TRUE; }
INLINE void Edge::setDirectionTo(NodePtr endpoint)
{
    assert(endpoint == source || endpoint == dest);
    isForward = (endpoint == dest) ? TRUE : FALSE;
}
@ %toggleOrientation setDirection
Regardless of the orientation of the node, given one endpoint we
want to be able to get the other node.
<<Edge methods>>=
    NodePtr getOtherNode(const NodePtr node) const;
<<Edge inline implementations>>=
INLINE NodePtr Edge::getOtherNode(const NodePtr node) const
{ return (node == source) ? dest : source; }
@ %def getOtherNode
We need a default constructor because we will be creating an
array of edges in bulk when we know how many of them are
in the graph.
<<Edge methods>>=
    Edge();
<<Edge method implementations>>=
Edge::Edge()
{
    <<default Edge constructor>>
}
@
After constructing an edge, we will need to initialize it.  
The default orientation will be from the source to the destination.
<<Edge methods>>=
    void init(Node* src, Node* dst, FlowAmount cap);
<<Edge method implementations>>=
void Edge::init(Node* src, Node* dst, FlowAmount cap)
{
    source = src;
    dest = dst;
    flow = 0;
    capacity = cap;
    isForward = TRUE;
}
@ %def init

<<Edge header include files>>=
<<C++ overhead>>=
@
\subsubsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "Edge.h"
#include "debug.h"
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>

<<Edge method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_EDGE
#define INLINE /*inline*/
<<Edge inline implementations>>
#undef INLINE 
#endif /*INLINE_EDGE*/
@
The header defines the [[Edge]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef EDGE_H
#define EDGE_H
#include "types.h"
<<Edge header include files>>

class Edge 
{
public:
    <<Edge methods>>
    <<C++ overhead>>
private:
    <<Edge data>>
};
@ %def Edge
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_EDGE
#define INLINE inline
<<Edge inline implementations>>
#undef INLINE 
#endif /*INLINE_EDGE*/

#endif /*EDGE_H*/
