\section{Phase-based Solver}
The solver manages the entire problem instance.  Initially
this includes the nodes and edges.  These are stored as contiguous
arrays (as opposed to allocating each one with [[new]])
to make memory management fast and simple.  These arrays are allocated
when the problem instance is read.
<<Solver data>>=
    Node*	nodes;
    Edge*	edges;
<<default Solver constructor>>=
    nodes = nil;
    edges = nil;
@ %def nodes edges
Just for safety checking, we should also keep track of the
number of elements in each of these arrays.
<<Solver data>>=
    int		numNodes;
    int		numEdges;
<<default Solver constructor>>=
    numNodes = numEdges = nil;
@ %def numNodes numEdges
We also need to know the source and sink nodes in the graph.
<<Solver data>>=
    NodePtr 	sourceNode;
    NodePtr 	sinkNode;
<<default Solver constructor>>=
    sourceNode = sinkNode = nil;
@ %def sourceNode sinkNode
\subsection{Solving}
<<Solver methods>>=
    void solve();
<<Solver method implementations>>=
void PhaseSolver::solve()
{
    <<initialize nodes and edges>>

    TRACE(int currentPhase = 0;)
    NodePtr strongBranch = getLowestBranch();
    while (strongBranch != nil) {
	TRACE(
	    if ( strongBranch->getLabel() != currentPhase) {
		currentPhase = strongBranch->getLabel();
		trout << "Phase " << currentPhase << endl;
	    }
	)
	processBranch(*strongBranch);
	strongBranch = getLowestBranch();
    }

    // convert to flow
}
@ %def solve
We need to saturate all source- and sink.adjacent edges, label the 
source-adjacent nodes 2, and label the others 1.
When we saturate an edge, we do {\em not} toggle its orientation.
This will prevent flow from going back to either the source
or the sink.
<<initialize nodes and edges>>=
    for (int i = 0 ; i < numEdges; i++) {
	Edge& edge = edges[i];
	// XXX need to worry about node that is adjacent to src and sink
	if (edge.getTail() == sourceNode) {
	    FlowAmount excess = edge.saturate();
	    edge.getHead()->setLabel(2);
	    edge.getHead()->setExcess(excess);
	    edge.getHead()->removeNeighbor(edge);
	} else if (edge.getHead() == sinkNode) {
	    FlowAmount excess = edge.saturate();
	    edge.getTail()->setExcess(-excess);
	    edge.getTail()->removeNeighbor(edge);
	}
    }
    for (int i = 1; i <= numNodes; i++) {
	if (nodes[i].getLabel() == 2) {
	    addStrongBranch(nodes[i]);
	} else {
	    nodes[i].setLabel(1);
	}
    }
@
\subsection{Processing Branches}
We process the tree one branch at a time looking for mergers or
relabeling nodes.  As soon as there is a merger, we stop processing
this branch to allow the main loop to fetch the next, lowest-labeled
branch from the buckets.  It could be that we resume processing this 
branch, which is OK.  In fact, it is probably desireable since
the branch has been inverted.  If there was no merger, we
move the branch to the next bucket.
<<Solver methods>>=
    void processBranch(Node& root);
<<Solver method implementations>>=
void PhaseSolver::processBranch(Node& root)
{
    Boolean performedMerger = processSubtree(root);
    if (!performedMerger) {
	addStrongBranch(root);	// XXX maybe this should be in solve
    }
}
@ %def processBranch
Below is recursive code to perform the DFS scan of a node's children and to
look for merger arcs among its neighbors.  Currently, the code
processes the nodes in post-order - i.e. the children are all processed
before the neighbors of this node are scanned.
If this function performs a merger, it returns immediately.
If any part of the sub-tree is split off and strong, it will
be put in the appropriate bucket where [[getLowestBranch]] will
find it.  If there is no merger, the label of this node is incremented.
The function returns true or false if we perform a merger.
<<Solver methods>>=
    Boolean processSubtree(Node& node);
<<Solver method implementations>>=
Boolean PhaseSolver::processSubtree(Node& node)
{
    NodeLabel label = node.getLabel();
    <<process all children>>
    <<look for merger among neighbors>>
    // no merger
    node.incrementLabel();
    node.resetIterations();
    TRACE(trout << "node " << node.getId() << " relabled to "
		<< node.getLabel() << endl;);
    return FALSE;
}
@ %def processSubtree
We process all children that have the same label as ours, [[label]].
If a child has a higher label, we just ignore it.  By monotonicity,
it can't have a label less than ours.  If we process the sub-tree
and that generates a merger we return immediately.
<<process all children>>=
    while (node.hasMoreChildren()) {
	Node& child = node.getCurrentChild();
	assert(child.getLabel() >= label);
	if (child.getLabel() == label) {
	    Boolean performedMerger = processSubtree(child);
	    if (performedMerger) {
		return TRUE;
	    }
	}
	node.advanceChildren();
    }
@
Processing neighbors is a bit different.  Here is where we look for
a merger to a node with label exactly one less that ours
(given that the arc has residual capacity).  
Given that, we will merge and return true immediately.
<<look for merger among neighbors>>=
    while (node.hasMoreNeighbors()) {
	Edge& neighborEdge = node.getCurrentNeighbor();
	Node& neighbor = *neighborEdge.getOtherNode(&node);
	if ((neighbor.getLabel() == (label - 1)) &&
	    (neighborEdge.residCapacity(node) > 0))
	{
	    merge(node, neighbor, neighborEdge);
	    return TRUE;
	}
	node.advanceNeighbors();
    }
@
This function 
rehangs the strong branch from the strong node, adds the
merger arc from $s$ to $w$, and pushes the excess from the
old strong root to the weak root.  If pushing the excess results
in any splitting, this function returns the lowest label of the
newly created branches.  Note that only splits within the
weak branch can yield labels less that $\ell$.  Because new 
branches with labels less than $\ell$ are the only ones that
will interrupt phase $\ell$, we are only concerned about such
splits within the weak branch.
<<Solver methods>>=
    NodeLabel merge(Node& strong, Node& weak, Edge& edge);
<<Solver method implementations>>=
NodeLabel PhaseSolver::merge(Node& strong, Node& weak, Edge& edge)
{
    TRACE( trout << "merge " << strong.getId() << " ("
		   << strong.getRootExcess() << ") to " 
		   << weak.getId() << " ("
		   << weak.getRootExcess() << "), cap "
		   << edge.residCapacity(strong) << endl;)
    Node& strongRoot = *strong.rehang();
    weak.addChild(strong, edge);
    CHECK_TREE(weak, weak.getParentEdge());
    CHECK_TREE(*weak.getRoot(), nil);
    strongPush(strongRoot, weak);
    NodeLabel splitLabel = weakPush(weak);

    return splitLabel;
}
@ %def merge
Push excess from the former strong root, $r_s$ to the strong node, $s$,
and one step beyond to the weak node, $w$.
When this finishes, the remaining excess will be stored on
the destination node.
We save the parent pointer before the push in case there is a
split, in which case the parent pointer will be [[nil]].
<<Solver methods>>=
    void strongPush(Node& src, Node& dest);
<<Solver method implementations>>=
void PhaseSolver::strongPush(Node& src, Node& dest)
{
    NodePtr currNode = &src;
    while (currNode != &dest) {
	NodePtr parent = currNode->getParentNode();
	Boolean performedSplit = currNode->pushToParent();
	if (performedSplit) {
	    if (currNode->getExcess() > 0) {	// ZERO_DEFICIT
		addStrongBranch(*currNode);
	    } // else - just a split, zero-deficit node?
	}
	currNode = parent;
    }
}
@ %def strongPush
Pushing on the weak side is similar in that it uses [[pushToParent]]
to push all of the flow, but it differs in that we push all the way
to the root of the branch, and we want to keep track of the lowest
labeled node that we split off.
<<Solver methods>>=
    NodeLabel weakPush(Node& src);
<<Solver method implementations>>=
NodeLabel PhaseSolver::weakPush(Node& src)
{
    NodeLabel splitLabel = MAX_LABEL;
    NodePtr currNode = &src;
    while (currNode->getParentNode() != nil) {
	NodePtr parent = currNode->getParentNode();
	Boolean performedSplit = currNode->pushToParent();
	if (performedSplit) {
	    CHECK_TREE(*currNode, nil);
	    if (currNode->getExcess() > 0) {	// ZERO_DEFICT
		addStrongBranch(*currNode);
		splitLabel = currNode->getLabel();
	    } // else - just a split, zero-deficit node?
	}
	currNode = parent;
    }
    CHECK_TREE(*currNode, nil);

    if (currNode->getExcess() > 0) {	// ZERO_DEFICT
	addStrongBranch(*currNode);
    }

    return splitLabel;
}
@ %def weakPush
\subsection{Managing Strong Branches}
We manage strong branches using an array of linked lists of Nodes.
We refer to each such element in the array as a `bucket'.
The buckets are indexed by the labels of the nodes.  Therefore,
we need a bucket for each possible label - basically $n$ buckets.
<<Solver data>>=
    NodePtr*	buckets;
<<default Solver constructor>>=
    buckets = nil;
@ %def buckets
Because we process the lowest labeled branch, we need a way to find
the strong branch quickly.  At the moment, we just search the list
sequentially looking for the lowest labeled, non-empty bucket.  To
speed this a bit, we keep track of the lowest labeled bucket we've
seen.  In the future, this simple array of buckets could be replaced
by some sort of heap.
<<Solver data>>=
    NodeLabel 	lowestLabel;
<<default Solver constructor>>=
    lowestLabel = 0;
@ %def lowestLabel
Adding a branch just requires finding the bucket based on the branch's
label, and inserting it into the list.  For simplicity, we add to
the head of the list.  This probably doesn't make any difference
(FIFO vs. LIFO) in a lowest label algorithm, but in the future, we
might want to experiment with this.  After adding the branch,
we need to see if the new branch has a lower label than our previous
lowest labeled branch.
<<Solver methods>>=
    void addStrongBranch(Node& root);
<<Solver method implementations>>=
void PhaseSolver::addStrongBranch(Node& root)
{
    NodeLabel label = root.getLabel();
    assert((root.getExcess() > 0) && (label > 0));	// ZERO_DEFICT
    // put in correct bucket
    if (buckets[label] == nil) {
	root.setNextNil();
	buckets[label] = &root;
    } else {
	root.setNext(buckets[label]);
	buckets[label] = &root;
    }
    // look for new, lower label
    if (label < lowestLabel) {
	lowestLabel = label;
    }
}
@ %def addStrongBranch
As the algorithm runs, we need to remove the lowest labeled branch.
First we need to locate the lowest labeled bucket, then we need to
remove the head of the list.  If there are no more strong branches,
we just return [[nil]].

The search always starts at the [[lowestLabel]] bucket.  As we
scan buckets, we increment [[lowestLabel]] until we find a 
non-empty bucket.
{\em What exactly should the termination condition be?}
<<Solver methods>>=
    NodePtr getLowestBranch();
<<Solver method implementations>>=
NodePtr PhaseSolver::getLowestBranch()
{
    NodePtr result = nil;
    while (lowestLabel < numNodes) {
	if (buckets[lowestLabel] != nil) {
	    result = buckets[lowestLabel];
	    buckets[lowestLabel] = result->getNext();
	    result->setNextNil();
	    break;
	} else {
	    lowestLabel++;
	}
    }

    return result;
}
@ %def getLowestBranch
<<Solver inline implementations>>=
<<header include files>>=
<<C++ overhead>>=
    PhaseSolver();
<<Solver method implementations>>=
PhaseSolver::PhaseSolver()
{
    <<default Solver constructor>>
}
@
\subsection{Input Output Functions}
We need routines to read Dimacs problem files and write 
Dimacs flow files.  At the moment, these are member
functions on the solver.  An alternative design would
be to put them in a separate class or file to allow us
to support multiple input file formats for the same 
solver class.

Our function to read a problem instance is given a file name and
return true if it sucessfully read the problem instance from the
specified file.
<<Solver methods>>=
    Boolean readDimacsInstance(const char* filename);
@
Our code will be divided into two steps. In the first
steps we will determine the basic dimensions of the problem, initialize
the edges, and compute the degree of each node.  Once we know the degree
of the nodes, we can initialize them and add all of their neighbors.

The code below uses C standard I/O ([[stdio]]) because I'm too lazy
to figure out how to use C++ I/O streams.  
<<Solver method implementations>>=
Boolean PhaseSolver::readDimacsInstance(const char* filename)
{
    FILE* fp = fopen(filename, "r");
    if (fp != NULL) {
	instanceFilename = filename;
	<<local variables for reading>>
	<<read instance and initialize edges>>
	<<initialize nodes>>
    } else {
	perror("Unable to read problem instance");
	return FALSE;
    }
    return TRUE;
}
<<implementation header files>>=
#include <stdio.h>
<<Solver data>>=
    const char* instanceFilename;
<<default Solver constructor>>=
    instanceFilename = "<unknown instance>";
@ %def readDimacsInstance
Reading the problem instance is farily straightforward.  We
read lines until the end of file.  Each line
in the file is identified by a `type character' that specifies what
type of line we are reading.  The type then determines how much more
information is on the line.  The additional information will begin 
at the third character in the line.
<<read instance and initialize edges>>=
    while (!feof(fp)) {
	char buffer[500];
	if (fgets(buffer, 500, fp) == NULL) {
	    break;
	}
	char* moreInfo = &buffer[2];
	char type;
	sscanf(buffer, "%c", &type);
	<<parse line>>
    }
@ 
Parsing the type code is a pretty simple switch statment.
<<parse line>>=
    switch (type) {
	case 'c':	// comment
	    break;
	case 'p':	// problem dimensions
	    <<allocate problem instance>>
	    break;
	case 'n':   {	// specify source or sink
	    <<specify source/sink>>
	    break;
	}
	case 'a':	// read an edge
	    <<read edge>>
	    break;
	default:
	    cerr << "Unrecognized input line: " << buffer << endl;
	    break;
    }
@
The problem instance has a problem type string, number of nodes,
and number of instances.  In addition to allocating the array
of nodes, we also allocate and zero an array of integers that we
will use to count the degree of each node as we read each edge.
Note that node id's begin at one rather than zero, so we need to
allocate an extra node (node zero), that never really gets used.
<<allocate problem instance>>=
    char typeBuffer[20];
    numTokens = sscanf(moreInfo, "%s %d %d", typeBuffer, &numNodes, &numEdges);
    if ((numTokens != 3) || (numNodes <= 0) || (numEdges <= 0)) {
	cerr << "Invalid problem instance line: " << buffer << endl;
	return FALSE;
    }
    nodes = new Node[numNodes + 1];
    edges = new Edge[numEdges];
    buckets = new NodePtr[numNodes + 1];
    nodeDegrees = new int[numNodes + 1];
    for (int i = 0; i <= numNodes; i++) {
	nodeDegrees[i] = 0;
	buckets[i] = nil;
    }
<<local variables for reading>>=
    int numTokens = 0;
    int* nodeDegrees = nil;
@ 
The source and sink in the graph are simply specified by a node number and `s'
for the source and `t' for the sink.
<<specify source/sink>>=
    char sourceSinkFlag;
    int nodeNumber;
    numTokens =  sscanf(moreInfo, "%d %c", &nodeNumber, &sourceSinkFlag);
    if ((numTokens != 2) || (nodeNumber <= 0) || (nodeNumber > numNodes)) {
	cerr << "Invalid source/sink line: " << buffer << endl;
	return FALSE;
    }

    if (sourceSinkFlag == 's') {
	sourceNode = &nodes[nodeNumber];
    } else if (sourceSinkFlag == 't') {
	sinkNode = &nodes[nodeNumber];
    } else {
	cerr << "Invalid source/sink line: " << buffer << endl;
	return FALSE;
    }
@ 
An edge is specified by a source, destination and a capacity.
<<read edge>>=
    int source, dest, capacity;
    numTokens =  sscanf(moreInfo, "%d %d %d", &source, &dest, &capacity);
    if ((numTokens != 3) || (source <= 0) || (source > numNodes) ||
	(capacity < 0)   || (dest <= 0)   || (dest > numNodes)) {
	cerr << "Invalid edge line: " << buffer << endl;
	return FALSE;
    }

    if (nextEdge < numEdges) {
	edges[nextEdge].init(nodes[source], nodes[dest], capacity);
	nextEdge++;
	nodeDegrees[source]++;
	nodeDegrees[dest]++;
    } else {
	cerr << "Too many edges - graph should only contain " << numEdges << endl;
	return FALSE;
    }
<<local variables for reading>>=
    int nextEdge = 0;
@
To initialize the nodes, we call their [[init]] method to allocate
space for neighbors based on the degree of each node that we observered
while reading edges.  We can trivially assign each node it's id number.
<<initialize nodes>>=
    for (int i = 1; i <= numNodes; i++) {
	nodes[i].init(i, nodeDegrees[i]);
    }
@
Once the nodes are initialized, we can easily iterate over the list of 
edges and add each endpoint to the other's list of neighbors.  Note,
we only scan the edges that we actually read (based on [[nextEdge]])
rather than the number we could have seen (specified by [[numEdges]]).
<<initialize nodes>>=
    for (int i = 0; i < nextEdge; i++) {
	edges[i].getHead()->addNeighbor(edges[i]);
	edges[i].getTail()->addNeighbor(edges[i]);
    }
@
Finally, let's remember to free up the memory we allocated to count
node degrees.
<<initialize nodes>>=
    delete[] nodeDegrees;
@
After we read an instance and solve it, we need to write the result
out.  The Dimacs flow file is very similar to the instance in
that every line is identified by an initial type character followed
by arguments.  After printing header information, we print the
total flow amount and the flow on each arc.
<<Solver methods>>=
    void writeDimacsFlow(const char* filename);
<<Solver method implementations>>=
void PhaseSolver::writeDimacsFlow(const char* filename)
{
    ofstream dout(filename, ios::out);
    if (dout == nil) {
	cerr << "Unable to open output file: " << filename << endl;
	return;
    }
    <<write header>>
    dout << "s " << 0 << endl;
    <<dump arcs>>
    dout.close();
}
@ %def writeDimacsFlow
<<write header>>=
    extern char* buildFlags;
    extern char* buildDate;
    dout << "c" << endl;
    dout << "c  buildFlags: " << buildFlags << endl;
    dout << "c  buildDate: " << buildDate << endl;
    dout << "c  instance: " << instanceFilename << endl;
    dout << "c  numNodes: " << numNodes << endl;
    dout << "c  numArcs: "  << numEdges << endl;
    dout << "c" << endl;
@
To dump the edges, we just iterate over the array of edges and 
print them out.
<<dump arcs>>=
    for (int i = 0; i < numEdges; i++) {
	edges[i].writeFlow(dout) << endl;
    }
@
Here is a new method to print the final disposition of all of the nodes
in the graph.  
<<Solver methods>>=
    void dumpNodes();
<<Solver method implementations>>=
void PhaseSolver::dumpNodes()
{
    cout << " Node id  excess  strong/weak" << endl;

    for (int i = 1; i <= numNodes; i++) {
	Node& node = nodes[i];
	cout << setw(8) << node.getId() << setw(8);
	if (&node == sourceNode) {
	    cout << "source";
	} else if (&node == sinkNode) {
	    cout << "sink";
	} else {
	     cout << node.getExcess() << setw(8)
		  << (node.isStrong() ? "strong" : "weak");
	 }
	 cout << endl;
    }
}
@ %def dumpNodes
\subsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "PhaseSolver.h"
#include "Node.h"
#include "debug.h"
#include <iostream.h>
#include <fstream.h>
#include <iomanip.h>
#include <assert.h>
<<implementation header files>>

<<Solver method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_SOLVER
#define INLINE /*inline*/
<<Solver inline implementations>>
#undef INLINE 
#endif /*INLINE_SOLVER*/
@
The header defines the [[Solver]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef SOLVER_H
#define SOLVER_H
#include "types.h"
<<header include files>>

class PhaseSolver 
{
public:
    <<Solver methods>>
    <<C++ overhead>>
private:
    <<Solver data>>
};
@ %def Solver
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_SOLVER
#define INLINE inline
<<Solver inline implementations>>
#undef INLINE 
#endif /*INLINE_SOLVER*/

#endif /*SOLVER_H*/
