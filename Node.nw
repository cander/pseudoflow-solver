\section{Data Declarations}
\subsection{Nodes in the Graph}
Nodes belong to both the original, complete graph as well as
the tree maintained by the solver.  Therefore, they have 
neighbors (in the original graph), and a parent and children (in
the tree).  In this lowest label implementation, they also have
labels associated with them.  We identify nodes by an id or node
number, which remains constant during the execution of the algorithm.
<<Node data>>=
    NodeId	id;
    NodeLabel	label;
<<header include files>>=
#include "types.h"
<<default Node constructor>>=
    id = -1;  label = -1;
<<Node methods>>=
public:
    NodeId getId() const;
<<Node inline implementations>>=
INLINE NodeId Node::getId() const
{ return id; }
@ %id label getId
As the algorithm progesses, the we check the label and increment it
by one.
<<Node methods>>=
public:
    NodeLabel getLabel() const;
    void incrementLabel();
<<Node inline implementations>>=
INLINE NodeLabel Node::getLabel() const
{ return label; }
INLINE void Node::incrementLabel()
{ label++; }
@ %def getLabel incrementLabel
A node can also have excess flow associated with it.  Typically,
this only occurs at a node that is adjacent to the pseduo-root
of the tree.  In our implementation, we store excess on nodes
in the middle of the tree temporarily while we are pushing it towards
the pseudo-root.
<<Node data>>=
    NodeExcess	excess;
<<default Node constructor>>=
    excess = 0;
@ %def excess
Of course, then we need methods to manipulate the excess.
<<Node methods>>=
    NodeExcess getExcess() const;
    void decrementExcess(NodeExcess delta);
    void setExcess(NodeExcess newExcess);
<<Node inline implementations>>=
INLINE NodeExcess Node::getExcess() const
{ return excess; }
INLINE void Node::decrementExcess(NodeExcess delta)
{ excess -= delta; }
INLINE void Node::setExcess(NodeExcess newExcess)
{ excess = newExcess; }
@ %def getExcess decrementExcess setExcess
To represent the graph, each node needs to store an list of neighbors.
To represent the tree, each node has list of children, which allows
us to search from the root down the tree.  
<<Node data>>=
    EdgeList	neighbors;
    EdgeList	children;	
<<header include files>>=
#include "EdgeList.h"
@ %def neighbors children
We can nodes add to these lists.  Adding a neighbor simply adds
it to the neighbor list.  
<<Node methods>>=
    void addNeighbor(EdgePtr nodep);
<<Node method implementations>>=
void Node::addNeighbor(EdgePtr edgep)
{ neighbors.appendEdge(edgep); }
@ %def addNeighbor
In order to scan from a node back up to the root, each node needs
to have a pointer to its parent.  During push operations, we also
need to know the residual capacity of the edge between the parent
and child, so we do not simply store a pointer to the parent,
rather we keep a pointer to the edge between the parent and
child, which seems a little indirect.
<<Node data>>=
    EdgePtr	parentEdge;
<<default Node constructor>>=
    parentEdge = nil;
<<header include files>>=
#include "Edge.h"
@ %def parentEdge
We can define some accessor methods to use the parent edge.
The parent edge is [[nil]] if the node is a root.
<<Node methods>>=
    EdgePtr	getParentEdge() const;
    NodePtr	getParentNode();
    Boolean	isRootNode() const;
<<Node inline implementations>>=
INLINE EdgePtr Node::getParentEdge() const
{ return parentEdge; }
INLINE NodePtr Node::getParentNode() 
{ return (parentEdge != nil) ? parentEdge->getOtherNode(this) : nil; }
INLINE Boolean Node::isRootNode() const
{ return (parentEdge == nil) ? TRUE : FALSE; }
@ %def getParentEdge getParentNode isRootNode
Adding a child is a more involved process than adding a neighbor
because we have to update the parent edge.  We begin by adding
the child to the parent's list of children.  
Then, we update the orientation of the 
orientation of the edge to point from child to parent.
And finally, we update set the child's parent edge.
<<Node methods>>=
    void addChild(NodePtr child, Edge& edge);
<<Node method implementations>>=
void Node::addChild(NodePtr child, Edge& edge)
{
    children.appendEdge(&edge);
    edge.setDirectionTo(this);
    child->parentEdge = &edge;
}
@ %def addChild
Rehanging a tree from a node involves reversing the
parent-child relationship between nodes along the
path from the new root node up to the existing
root.  

At the center of the parent-child relationship is the edge between
the parent and child.  This is the [[parentEdge]] in the current
node ([[this]]), and it is stored the [[children]] list in the
parent node.  We remove the edge from our parent's list of children
and recursively tell the parent to rehang itself.  Once the tree
is rehung by the parent, we install as a sub-tree under our node
by by setting the parent's [[parentEdge]] pointer to the edge and
adding the edge to our children list.  Since we reversed the
orientation of the two nodes, we need to toggle the direction of
the edge.  Finally, the current node is the root of a sub-tree, so
its parent edge is set to [[nil]].

As indicated, the code is written as a recursive function because
it is easiest to code that way.  In the future, if the function
call overhead becomes a bottleneck, we can recode it iteratively.

In this code, we will take advantage of the fact that we know we
must have been iterating through the children arrays of the nodes
along the path to get to a node that we are going to rehang by.
For a given node, $v$, we know that $v$ must be the current node
in the children array of the parent of $v$.  This makes it simple
and fast to find $v$ in its parent's children array.

<<Node methods>>=
    void rehang();
<<Node method implementations>>=
void Node::rehang()
{
    NodePtr parentNode = getParentNode();
    if (parentNode != nil) {
	assert (label == parentNode->label);
	EdgePtr edge = parentEdge;
	parentNode->children.removeCurrentElement(edge);
	parentNode->rehang();

	parentNode->parentEdge = edge;
	children.addCurrentElement(edge);
	edge->toggleOrientation();
	parentEdge = nil;
    }
}
@
We need a default constructor because we will be creating an
array of nodes in bulk when we know how many of them are
in the graph.
<<C++ overhead>>=
    Node();
<<Node method implementations>>=
Node::Node()
{
    <<default Node constructor>>
}
@
After constructing a node, we will need to initialize it.  By the time
we initialize it, we need to know the number of neighbors so we
can allocate the neighbor and children arrays.
<<Node methods>>=
    void init(NodeId id, int numNeighbors);
<<Node method implementations>>=
void Node::init(NodeId id, int numNeighbors)
{
    this->id = id;
    neighbors.init(numNeighbors);
    children.init(numNeighbors + 3);
}
@ init
To aid in debugging the tree and graph manipulation functions,
we have some functions that we can use to print and check the
data structures.
<<debugging functions>>=
    public: void printTree(int level);
<<Node method implementations>>=
void Node::printTree(int level)
{
    if (level == 0) {
	cout << " Node id  address   level   label  parent  excess" << endl;
    }

    cout << setw(8) << id << "   "
         << setw(8) << this
	 << setw(8) << level
	 << setw(8) << label;

    cout << setw(8);
    if (isRootNode()) {
	cout << "NULL";
    } else {
	cout << getParentNode()->id;
    }

    cout << setw(8) << excess << endl;

    // examine children
    int numChildren = children.getSize();
    int childLevel = level + 1;
    for (int i = 0; i < numChildren; i++) {
	EdgePtr childEdge = children.getElement(i);
	if (childEdge != nil) {
	    NodePtr child = childEdge->getOtherNode(this);
	    child->printTree(childLevel);
	}
    }
}
@ %def printTree
Here's a 'C' version of the function that we can call from {\em gdb}.
void printTree(Node* n)
{
    n->printTree(0);
}
@
Sometimes, we also need to check the consistency of the tree,
especially after operations like rehanging the tree.
The code recursively explores the tree in pre-order to validate
the pointers from a child node back to its parent and vice versa.
For each node, we check its parent edge pointer then investigate
the children.  As soon as we detect any error in the tree, we
stop immediately, since there may be zillions of errors, which would
swamp the output that we look at.
<<debugging functions>>=
    Boolean checkTree(EdgePtr expectedParentEdge);
<<Node method implementations>>=
Boolean Node::checkTree(EdgePtr expectedParentEdge)
{
    Boolean treeOK = TRUE;
    cout << id << " ";
    <<check parent pointers>>

    if (treeOK) {
	<<check child pointers>>
    }

    return treeOK;
}
@ %def checkTree
First we check our pointer to our parent.  This could be [[nil]] if
we are a root, otherwise it better bet the same edge that our parent
tells us it should be.  Furthermore, the edge should point from us
(the tail) up to our parent.
<<check parent pointers>>=
    if (expectedParentEdge != nil) {
	if (parentEdge != expectedParentEdge) {
	    cout << "\nError: node " << id << " parent edge wrong. "
	         << " expected " << expectedParentEdge << endl
		 << " \tfound " << parentEdge << endl;
	    treeOK = FALSE;
	} else {
	    if (parentEdge->getTail() != this) {
		cout << "\nError: node " << id 
		     << " parent edge orientation wrong: "
		     << parentEdge << endl;
		treeOK = FALSE;
	    }
	}
    } else {
	if (parentEdge != nil) {
		cout << "\nError: node " << id 
		     << " expected nil parent edge, found: "
		     << parentEdge << endl;
		treeOK = FALSE;
	}
    }
@
To investigate the children, we just iterate over our list of children
and check each of them in turn.  We must skip holes in the list
(denoted by [[nil]] entries).
<<check child pointers>>=
    int numChildren = children.getSize();
    for (int i = 0; i < numChildren; i++) {
	EdgePtr childEdge = children.getElement(i);
	if (childEdge != nil) {
	    NodePtr childNode = childEdge->getOtherNode(this);
	    treeOK = childNode->checkTree(childEdge);
	    if (treeOK == FALSE) {
		break;
	    }
	}
    }
@
\subsubsection{File Boiler Plate}
We start with the boiler-plate implementation file. 
<<*>>=
#include "Node.h"
#include "debug.h"
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>

<<Node method implementations>>
@
Through magic of the C preprocessor and the macro-like facilities
of {\em noweb}, we can easily define the inline functions
out-of-line to allow us to collect better profile information - 
i.e. collect data on the inline functions that would otherwise
not show up in the function call traces of the profiler.
<<*>>=
#ifndef INLINE_NODE
#define INLINE /*inline*/
<<Node inline implementations>>
#undef INLINE 
#endif /*INLINE_NODE*/
@
The header defines the [[Node]] class, its member functions, member
data, and inline functions.  Again, we have more boiler-plate.
<<header>>=
#ifndef NODE_H
#define NODE_H
<<header include files>>

class Node 
{
    <<Node methods>>
    <<debugging functions>>
    <<C++ overhead>>
private:
    <<Node data>>
};
@ %def Node
In case we want the inline functions to really be inlined, we
also define them here in the header file.
<<header>>=
#ifdef INLINE_NODE
#define INLINE inline
<<Node inline implementations>>
#undef INLINE 
#endif /*INLINE_NODE*/

#endif /*NODE_H*/
